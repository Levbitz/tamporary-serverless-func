'use strict'

<<<<<<< HEAD
const addExpectedVersions = function ({ pluginsOptions }) {
=======
const { logInvalidAutoPlugin } = require('../log/messages/plugins')
const { resolvePath } = require('../utils/resolve')

const { getPluginsList } = require('./list')

// When using plugins in our official list, those are installed in .netlify/plugins/
// We ensure that the last version that's been approved is always the one being used.
// We also ensure that the plugin is our official list.
const addExpectedVersions = async function ({ pluginsOptions, autoPluginsDir, debug, logs, testOpts }) {
>>>>>>> cac8ece8a... Improve how plugins are installed
  if (!pluginsOptions.some(isAutoPlugin)) {
    return pluginsOptions
  }

<<<<<<< HEAD
  return pluginsOptions.map(addExpectedVersionUnlessPath)
=======
  const pluginsList = await getPluginsList({ debug, logs, testOpts })
  return pluginsOptions.map((pluginOptions) => addExpectedVersion({ pluginsList, autoPluginsDir, pluginOptions, logs }))
>>>>>>> cac8ece8a... Improve how plugins are installed
}

const isAutoPlugin = function ({ loadedFrom }) {
  return loadedFrom === 'auto_install'
}

<<<<<<< HEAD
const addExpectedVersionUnlessPath = function ({ pluginPath, ...pluginOptions }) {
  if (pluginPath !== undefined) {
    return { ...pluginOptions, pluginPath }
  }

  return { ...pluginOptions, expectedVersion: 'latest' }
=======
// Any `pluginOptions` with `expectedVersion` set will be automatically installed
const addExpectedVersion = async function ({
  pluginsList,
  autoPluginsDir,
  pluginOptions,
  pluginOptions: { packageName, pluginPath },
  logs,
}) {
  const expectedVersion = pluginsList[packageName]

  // Plugins that are not in our official list can only be specified in
  // `netlify.toml` providing they are also installed in the site's package.json.
  // Otherwise, the build should fail. For backward compatibility, we only print
  // a warning message at the moment.
  // TODO: fail the build instead
  if (expectedVersion === undefined) {
    logInvalidAutoPlugin(logs, packageName)
    return { ...pluginOptions, expectedVersion: 'latest' }
  }

  // Plugin was not previously installed
  if (pluginPath === undefined) {
    return { ...pluginOptions, expectedVersion }
  }

  const { version } = await resolvePath(`${packageName}/package.json`, autoPluginsDir)

  // Plugin was previously installed but a new version is available
  if (version !== expectedVersion) {
    return { ...pluginOptions, expectedVersion }
  }

  return pluginOptions
>>>>>>> cac8ece8a... Improve how plugins are installed
}

module.exports = { addExpectedVersions }
