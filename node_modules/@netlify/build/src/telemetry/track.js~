const {
<<<<<<< HEAD
  env: { TEST_HOST },
=======
  env: { BUILD_TELEMETRY_DISABLED },
>>>>>>> Add `testOpts.telemetryOrigin` flag
} = require('process')

const Analytics = require('analytics').default
const execa = require('execa')

const { version } = require('../../package.json')
const REQUEST_FILE = `${__dirname}/request.js`

// Send HTTP request to telemetry.
// Telemetry should not impact build speed, so we do not wait for the request
// to complete, by using a child process.
// We also ignore any errors. Those might happen for example if the current
// directory was removed by the build command.
<<<<<<< HEAD
const track = async function({ payload: { properties: { telemetry, payload: properties } = {}, ...payload } = {} }) {
  if (!telemetry) {
=======
const track = async function({
  payload: { properties: { telemetry, testOpts: { telemetryOrigin = '' } = {}, payload: properties } = {}, ...payload } = {},
}) {
  if (BUILD_TELEMETRY_DISABLED) {
>>>>>>> Add `testOpts.telemetryOrigin` flag
    return
  }

  const payloadA = { ...payload, properties }
  try {
<<<<<<< HEAD
    const childProcess = execa('node', [REQUEST_FILE, JSON.stringify(payloadA)], { detached: true, stdio: 'ignore' })
=======
    const childProcess = execa('node', [REQUEST_FILE, JSON.stringify(payloadA), telemetryOrigin], {
      detached: true,
      stdio: 'ignore',
    })
>>>>>>> Add `testOpts.telemetryOrigin` flag

    // During tests, we wait for the HTTP request to complete
    if (telemetryOrigin === '') {
      childProcess.unref()
    }

    await childProcess
  } catch (error) {
    return
  }
}

const analytics = Analytics({
  app: 'netlifyCI',
  version,
  plugins: [{ NAMESPACE: 'netlify-telemetry', track }],
})

module.exports = { analytics }
